<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="PowerShell Scripts and Techniques : powershell scripts" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>PowerShell Scripts and Techniques</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/jorgecarpio/ps_scripts">View on GitHub</a>

          <h1 id="project_title">PowerShell Scripts and Techniques</h1>
          <h2 id="project_tagline">powershell scripts</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/jorgecarpio/ps_scripts/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/jorgecarpio/ps_scripts/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a name="powershell-scripts-and-techniques" class="anchor" href="#powershell-scripts-and-techniques"><span class="octicon octicon-link"></span></a>PowerShell Scripts and Techniques</h3>

<p>Here is a set of PowerShell one-liners, links, scripts and techniques that I've found useful (but can't always keep on the tip of my tongue).  </p>

<p>You'll need the Active Directory cmdlets for many of these.</p>

<h2>Interesting PowerShell links</h2>
<p><a href="http://mikepfeiffer.net/2010/04/working-with-duplicate-array-values-in-powershell/">Find dupes in an array</a></p>
<p><a href="http://gallery.technet.microsoft.com/scriptcenter/Get-nested-group-15f725f2">Get nested AD Group membership</a></p>
<p><a href="http://gallery.technet.microsoft.com/scriptcenter/Get-LockedOutLocation-b2fd0cab">Find the machine locking an AD account</a></p>

<h2>Find ALL the groups a user is a member of</h2>
<p>Because dsa.msc only gives a superficial list</p>
<pre><code>get-adgroup -LDAPFilter "(member:1.2.840.113556.1.4.1941:=CN=Wallace, David F.,OU=TheUsers,DC=domain,DC=com)" </code></pre>

<h2>Pass variable strings to filter blocks for commands like get-aduser</h2>
<p>Useful because PowerShell doesn't handle quotes well.  Piping $name right to get-aduser's filter block here will not force interpolation on the string.</p> 
<p>This example will get names from a list and move then to an OU</p>
<pre><code>foreach ($name in (gc .\names.txt)) {
$user = "*$name*"
get-aduser -filter "name -eq '$user'" | Move-ADObject -TargetPath $ou -WhatIf
}</code></pre>

<h2>Dig through all the property values for an AD user; handy if you don't know which specific property to look for</h2>
<pre><code>get-aduser joesmith -Properties * | foreach-object `
{ foreach ($property in $_.PSObject.Properties) `
{ if ($property.value -like "*1234*") `
{ write-host "$($property.name) $($property.value)" } } }</code></pre>

<h2>
<a name="list-all-the-windows-servers-in-a-domain-and-export-them-to-csv" class="anchor" href="#list-all-the-windows-servers-in-a-domain-and-export-them-to-csv"><span class="octicon octicon-link"></span></a>List all the Windows servers in a domain and export them to csv</h2>

<pre><code>Get-ADComputer -Filter {OperatingSystem -Like "Windows *Server*"}
    -Properties * | Select-Object Name,OperatingSystem | 
    Export-Csv AllServers.csv -NoTypeInformation -Encoding UTF8
</code></pre>

<p>Instead of csv, prints a table to standard out</p>

<pre><code>Get-ADComputer -filter {(PasswordLastSet -le $date)
    -and (OperatingSystem -Like "Windows *Server*")} 
    -Properties * | select-object Name,OperatingSystem,PasswordLastSet 
    | Format-table Name,OperatingSystem,PasswordLastSet -Wrap -Auto
</code></pre>

<h2>
Run PowerShell scripts with alt credentials</h2>
<p>Run PowerShell scripts with alt credentials</p>

<pre><code>$username = "username"
# Save password to cred.txt using
# read-host -assecurestring | convertfrom-securestring | out-file c:\bin\cred.txt
$password = ConvertTo-SecureString (get-content c:\bin\cred.txt)
$credentials = new-object -typename System.Management.Automation.PSCredential -argumentlist $username, $password
start-process powershell.exe -Credential $credentials -argumentlist "-File c:\bin\script.ps1" -wait
</code></pre>

<h2>
<a name="list-servers-who-have-computer-passwords-older-than-90-days" class="anchor" href="#list-servers-who-have-computer-passwords-older-than-90-days"><span class="octicon octicon-link"></span></a>List servers who have computer passwords older than 90 days</h2>

<p>These are ostensibly expired computer accounts.  Exports to csv. </p>

<pre><code>$date = [DateTime]::Today.AddDays(-90)

Get-ADComputer -filter {(PasswordLastSet -le $date) -and 
    (OperatingSystem -Like "Windows *Server*")} -Properties * 
    | select-object Name,OperatingSystem,PasswordLastSet 
    | Export-csv old.csv -NoTypeInformation -Encoding UTF8
</code></pre>

<h2>
<a name="query-active-directory-and-ping-results" class="anchor" href="#query-active-directory-and-ping-results"><span class="octicon octicon-link"></span></a>Query Active Directory and ping results</h2>

<p>Useful as a filter, prior to performing an action on computers en masse thus preventing RPC errors.
This pulls every computer; modify it appropriately.</p>

<pre><code>Import-Module active*
$rtn = $null
Get-ADComputer -Filter * | ForEach-Object {
    $rtn = Test-Connection -CN $_.dnshostname 
    -Count 1 -BufferSize 16 -Quiet
    IF($rtn -match 'True') {write-host -ForegroundColor 
        green $_.dnshostname}
    ELSE {write-host -ForegroundColor red $_.dnshostname}
}
</code></pre>

<h2>
<a name="change-dns-servers-and-search-order-ip-and-mask-router" class="anchor" href="#change-dns-servers-and-search-order-ip-and-mask-router"><span class="octicon octicon-link"></span></a>Change DNS Servers and Search Order; IP and Mask; Router</h2>

<pre><code>$wmi = Get-WmiObject win32_networkadapterconfiguration 
    -filter "ipenabled = 'true'"
$wmi.EnableStatic("192.168.1.10", "255.255.255.0")
$wmi.SetGateways("192.168.1.1",1)
$wmi.SetDNSServerSearchOrder("192.168.1.4")
</code></pre>

<p>or multiple DNS</p>

<pre><code>$dnsservers = "192.168.1.4","192.168.1.5"
$wmi.SetDNSServerSearchOrder($dnsservers)
</code></pre>

<h2>
<a name="change-fsmo-roles" class="anchor" href="#change-fsmo-roles"><span class="octicon octicon-link"></span></a>Change FSMO Roles</h2>

<p>Use <code>netdom query FSMO</code> to get FSMO roles.
Of course, you should know what roles correspond to which numbers [0..4]</p>

<pre><code>Move-ADDirectoryServerOperationMasterRole -identity 
    "servername" -OperationMasterRole 0,1,2,3,4
</code></pre>

<h2>
<a name="modify-an-attribute-or-attributes-of-all-users-in-an-ou" class="anchor" href="#modify-an-attribute-or-attributes-of-all-users-in-an-ou"><span class="octicon octicon-link"></span></a>Modify an attribute (or attributes) of all users in an OU</h2>

<pre><code>Get-aduser â€“filter * -SearchBase 
    "ou=YourOU,ou=YourSubOU,ou=YourSubSubOU,dc=yourdomain,dc=com" 
    | set-aduser -PasswordNeverExpires $true
</code></pre>

<h2>
<a name="find-a-users-ad-account-if-you-dont-know-their-account-name" class="anchor" href="#find-a-users-ad-account-if-you-dont-know-their-account-name"><span class="octicon octicon-link"></span></a>Find a user's AD account if you don't know their account name.</h2>

<p>You only know their first and last name (i.e. Herman Melville).</p>

<pre><code>Get-ADUser -Filter 'Name -like "*melville*"'
</code></pre>

<h2>
<a name="add-an-ad-user-to-a-group" class="anchor" href="#add-an-ad-user-to-a-group"><span class="octicon octicon-link"></span></a>Add an AD user to a group</h2>

<pre><code>Add-ADGroupMember 'Billing' hmelville
</code></pre>

<h2>
<a name="verify-a-user-is-a-member-of-a-group" class="anchor" href="#verify-a-user-is-a-member-of-a-group"><span class="octicon octicon-link"></span></a>Verify a user is a member of a group</h2>

<pre><code>get-adgroup 'Billing' | where name -like "*melville*"
</code></pre>

<h2>
<a name="use-echoargsexe-to-verify-external-commands-prior-to-use" class="anchor" href="#use-echoargsexe-to-verify-external-commands-prior-to-use"><span class="octicon octicon-link"></span></a>Use echoargs.exe to verify external commands prior to use</h2>

<p>Here a text file full of dnscmd generated zone information is parsed for a DNS server's zones.
Then echoargs will show you how parameters are passed to the external command dnscmd.  You'll see if any extra quotes are passed, or not before executing mudged commands on your production servers.</p>

<p>Dnscmd, if you care, is used here to add two secondary servers (192.168.1.5 and 192.168.1.6) to each zone for a server.</p>

<p>Note the &amp; prior to the called command; keep this when finally invoking your command.</p>

<pre><code>gc .\stuff.txt | select-string -Pattern "Primary" 
    | foreach {$zone = ($_ -split '\s+')[1]; 
    $callargs = @($server, "/ZoneResetSecondaries", 
    $zone, "/SecureList", "192.168.1.5", "192.168.1.6", "/Notify") ;
    &amp;c:\bin\echoargs.exe dnscmd $callargs}
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">PowerShell Scripts and Techniques maintained by <a href="https://github.com/jorgecarpio">jorgecarpio</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
